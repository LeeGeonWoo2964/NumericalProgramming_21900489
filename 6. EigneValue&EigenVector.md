# EigneValue&EigenVector
  
## using for
 - 어떠한 system에서 EigenValue와 EigenVector를 구하는 데에 사용된다.
## Concept of EigneValue and EigenVector
- 0 벡터가 아닌 벡터 v에 행렬 A를 곱해 행렬변환을 한다고 가정하였을 때 대부분의 경우에서 Av는 v의 상수배가 아니다. 하지만 드물게 상수배가 되는 경우가 있는 데 이때 v를 A의 EigenVector라고 하고 이 상수값을 EigenValue라고 한다.

$$v=\begin{bmatrix}v_{2}\\\\v_{1}\end{bmatrix}$$

$$A=\begin{bmatrix}a_{11}&a_{12}\\\\a_{21}&a_{22}\end{bmatrix}$$

Thus
$$Av=λv$$
$$(A-λI)v=0$$


 - EigenValue:
   
    - System이 어떠한 반응을 얼마나 빠르게 하는 지 보여주는 Value이다.

 - EigenVector:

     - System이 어떠한 반응을 하는 지를 보여주는 Vector이다. 


## EigneValue

### QR factorization-using Householder matrix

### Main Idea
- 이때 Q는 Orthogonal Matrix이기 때문에 inverse Q = Transpose Q이다.
- QR factorization은 EigenValue를 보존하면서 A를 Upper truangular Matrix로 만들어 주고 이때 A의 주대각 성분들이 EigenValue인 것을 이용한다. 

### QR factorization-using Householder matrix formular
Define Parameter

$R^{0}=A, Q^{0}=I$

$R^{n-1}=H^{n-1}R^{n-2}=H^{n-1}H^{n-2}\ldots H^{1}A$

$Q^{n-1}=Q^{n-2}H^{n-1}=H^{1}H^{2}\ldots H^{n-1}$

$c_{k}=R_{k}(:,k)$

ck는 Rk의 k번째 열

$$e_{k}=\begin{bmatrix}0\\\\0\\\\0\\\\0\\\\e_{k}\\\\\vdots\end{bmatrix}$$

$e_{k}$는 k번째 행의 성분을 제외한 다른 모든 성분이 0인 벡터이다. 

if $c_{k}>=0$    

$e_{k}=+1$

if $c_{k}<0$

$e_{k}=-1$

$v(n,1)=c+||c||e_{k}$

$H(n,n)=I-\frac{2}{v^{T}v}vv^{T}$

### Error Condition

### EigenValue Code
```C
void eigenVal(const Matrix A, Matrix val)
{
	if (A.rows != val.rows || val.cols != 1 || A.rows != A.cols)
	{
		printf("Error: \n");

		return;
	}

	Matrix Ak = zeros(A.rows, A.cols);
	copyMat(A,Ak);

	Matrix R = zeros(A.rows, A.cols);
	
	Matrix Q = zeros(A.rows, A.cols);
	eye(Q);

	copyVal(zeros(A.rows, A.cols), val);

	for (int i = 0; i < 100; i++)
	{
		copyMat(Ak, R);
		QR_fact(Ak, R, A);
		Ak = multMat(R, Q);
		printf("i=%d\n", i);
	}
	for (int idx = 0; idx < A.rows; idx++)
		val.at[idx][0] = Ak.at[idx][idx];
}
```



### QR_fact Code
```C
void QR_fact(const Matrix A, Matrix Q, Matrix R)
{
	/*define Parameter
	R = A
	Q = I
	*/

	if (A.rows != A.cols || A.rows != Q.rows || A.cols != Q.cols || A.rows != R.rows || A.cols != R.cols)
	{
		printf("Size Error\n");
		return;
	}

	Matrix v = zeros(A.rows, 1);
	Matrix I = zeros(A.rows, A.cols);
	eye(I);
	//Matrix H = createMat(A.rows, A.cols);
	Matrix v_outter = multMat(v, transpose(v));//v*vT
	Matrix H = subMat(I, v_outter);//I-v*vT(???????????????????)
	double c_norm = 0.;
	double v_inner = 0.;//vT*v

	for (int col = 0; col < A.cols; col++)
	{
		copyVal(zeros(A.rows, 1), v);
		c_norm = 0.;

		for (int row = 0; row < A.rows; row++)
		{
			v.at[row][0] = R.at[row][col];
			c_norm += v.at[row][0] * v.at[row][0];
		}
		c_norm = sqrt(c_norm);

		if (v.at[col][0] >= 0)
			v.at[col][0] += c_norm;
		else
			v.at[col][0] -= c_norm;

		/*if (v.at[col][0] >= 0)
			v.at[col][0] += c_norm;
		else
			v.at[col][0] -= c_norm;*/
		//v 계산 마무리
		
		//VtransposeV 랑 VVtranspose를 구하기

		//내적
		for (int row = 0; row < v.rows; row++)
			v_inner += v.at[row][0] * v.at[row][0];

		if (v_inner == 0.)
		{
			printf("Error: \n");

			return;
		}
```

### Ex code
```C
int main(){
Matrix A;// System matrix
Matrix val;//EigenValue를 저장할 vector
eigenVal( A, val);
return 0;
}
```

=====================
## EigneVector

### Using (A-λI)v=0

### Main Idea
- $(A-λI)v=0$인 것을 이용해서 v를 계산한다.

$$B=(A-λI)=\begin{bmatrix}b_{11}&b_{12}&b_{13}\\\\b_{21}&b_{22}&b_{23}\\\\b_{31}&b_{32}&b_{33}\end{bmatrix}$$

$$v=\begin{bmatrix}v_{1}\\\\v_{2}\\\\v_{3}\end{bmatrix}$$


### method 1 formular

### Error Condition

### method 1 Code

### Ex code
